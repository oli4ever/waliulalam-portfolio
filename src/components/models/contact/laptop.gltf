
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        
        // Renderer setup
        renderer.setSize(800, 600);
        renderer.setClearColor(0xf0f0f0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Window light (simulating natural light from the image)
        const windowLight = new THREE.DirectionalLight(0xffffff, 0.3);
        windowLight.position.set(-5, 5, 10);
        scene.add(windowLight);
        
        // Materials
        const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const laptopMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
        const screenMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const mugMaterial = new THREE.MeshLambertMaterial({ color: 0xB8860B }); // Changed to golden brown
        const glassMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7 });
        const flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
        const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xE8E8E8 }); // Changed to light gray
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C }); // Changed to tan
        
        // Store objects for color changes
        let mugObjects = [];
        let wallObjects = [];
        let floorObjects = [];
        
        // Create desk
        const deskGeometry = new THREE.BoxGeometry(8, 0.2, 4);
        const desk = new THREE.Mesh(deskGeometry, woodMaterial);
        desk.position.y = -0.1;
        desk.receiveShadow = true;
        desk.name = "desk";
        scene.add(desk);
        
        // Create desk legs
        const legGeometry = new THREE.BoxGeometry(0.2, 2, 0.2);
        const positions = [
            [-3.8, -1.1, 1.8], [3.8, -1.1, 1.8],
            [-3.8, -1.1, -1.8], [3.8, -1.1, -1.8]
        ];
        positions.forEach((pos, index) => {
            const leg = new THREE.Mesh(legGeometry, woodMaterial);
            leg.position.set(...pos);
            leg.castShadow = true;
            leg.name = `desk_leg_${index}`;
            scene.add(leg);
        });
        
        // Create laptop base
        const laptopBaseGeometry = new THREE.BoxGeometry(2.5, 0.1, 1.8);
        const laptopBase = new THREE.Mesh(laptopBaseGeometry, laptopMaterial);
        laptopBase.position.set(0, 0.05, 0);
        laptopBase.castShadow = true;
        laptopBase.name = "laptop_base";
        scene.add(laptopBase);
        
        // Create laptop screen
        const screenGeometry = new THREE.BoxGeometry(2.4, 1.5, 0.1);
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.set(0, 0.75, -0.8);
        screen.rotation.x = -Math.PI * 0.15;
        screen.castShadow = true;
        screen.name = "laptop_screen";
        scene.add(screen);
        
        // Create coffee mug
        const mugGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, 16);
        const mug = new THREE.Mesh(mugGeometry, mugMaterial);
        mug.position.set(2.5, 0.2, 0.5);
        mug.castShadow = true;
        mug.name = "coffee_mug";
        mugObjects.push(mug);
        scene.add(mug);
        
        // Create mug handle
        const handleGeometry = new THREE.TorusGeometry(0.2, 0.05, 8, 16);
        const handle = new THREE.Mesh(handleGeometry, mugMaterial);
        handle.position.set(2.8, 0.2, 0.5);
        handle.rotation.z = Math.PI / 2;
        handle.castShadow = true;
        handle.name = "mug_handle";
        mugObjects.push(handle);
        scene.add(handle);
        
        // Create glass vase
        const vaseGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16);
        const vase = new THREE.Mesh(vaseGeometry, glassMaterial);
        vase.position.set(-2.5, 0.4, 0);
        vase.castShadow = true;
        vase.name = "glass_vase";
        scene.add(vase);
        
        // Create small ceramic vase
        const ceramicVaseGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.6, 16);
        const ceramicVase = new THREE.Mesh(ceramicVaseGeometry, new THREE.MeshLambertMaterial({ color: 0xD2B48C }));
        ceramicVase.position.set(-2, 0.3, 0.8);
        ceramicVase.castShadow = true;
        ceramicVase.name = "ceramic_vase";
        scene.add(ceramicVase);
        
        // Create flowers
        const flowerPositions = [
            [-2.5, 0.9, 0], [-2.3, 1.1, 0.1], [-2.7, 1.0, -0.1],
            [-2.4, 1.2, 0.2], [-2.6, 0.95, 0.15]
        ];
        
        flowerPositions.forEach((pos, index) => {
            // Flower head
            const flowerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            flower.position.set(...pos);
            flower.name = `flower_${index}`;
            scene.add(flower);
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            const stem = new THREE.Mesh(stemGeometry, leafMaterial);
            stem.position.set(pos[0], pos[1] - 0.15, pos[2]);
            stem.name = `stem_${index}`;
            scene.add(stem);
        });
        
        // Create leaves
        const leafPositions = [
            [-2.2, 0.8, 0.1], [-2.8, 0.85, -0.1], [-2.4, 0.75, 0.2]
        ];
        
        leafPositions.forEach((pos, index) => {
            const leafGeometry = new THREE.PlaneGeometry(0.15, 0.3);
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.set(...pos);
            leaf.rotation.y = Math.random() * Math.PI;
            leaf.name = `leaf_${index}`;
            scene.add(leaf);
        });
        
        // Create back wall
        const wallGeometry = new THREE.PlaneGeometry(16, 8);
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(0, 3, -6);
        wall.receiveShadow = true;
        wall.name = "back_wall";
        wallObjects.push(wall);
        scene.add(wall);
        
        // Create window frame
        const windowFrameGeometry = new THREE.BoxGeometry(3, 4, 0.1);
        const windowFrame = new THREE.Mesh(windowFrameGeometry, new THREE.MeshLambertMaterial({ color: 0x333333 }));
        windowFrame.position.set(3, 3, -5.9);
        windowFrame.name = "window_frame";
        scene.add(windowFrame);
        
        // Create window glass
        const windowGlassGeometry = new THREE.PlaneGeometry(2.8, 3.8);
        const windowGlass = new THREE.Mesh(windowGlassGeometry, new THREE.MeshLambertMaterial({ 
            color: 0xE6F3FF, 
            transparent: true, 
            opacity: 0.3 
        }));
        windowGlass.position.set(3, 3, -5.85);
        windowGlass.name = "window_glass";
        scene.add(windowGlass);
        
        // Create floor
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2;
        floor.receiveShadow = true;
        floor.name = "floor";
        floorObjects.push(floor);
        scene.add(floor);
        
        // Camera setup
        camera.position.set(5, 3, 8);
        camera.lookAt(0, 0, 0);
        
        // Mouse controls
        let mouseX = 0, mouseY = 0;
        let isMousePressed = false;
        
        document.addEventListener('mousemove', (event) => {
            if (isMousePressed) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }
            mouseX = event.clientX;
            mouseY = event.clientY;
        });
        
        document.addEventListener('mousedown', () => isMousePressed = true);
        document.addEventListener('mouseup', () => isMousePressed = false);
        
        // Wheel zoom
        document.addEventListener('wheel', (event) => {
            const direction = event.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(direction);
            camera.position.clampLength(3, 20);
        });
        
        // Color change handlers
        document.getElementById('mugColor').addEventListener('change', (event) => {
            const color = new THREE.Color(event.target.value);
            mugObjects.forEach(obj => obj.material.color = color);
        });
        
        document.getElementById('wallColor').addEventListener('change', (event) => {
            const color = new THREE.Color(event.target.value);
            wallObjects.forEach(obj => obj.material.color = color);
        });
        
        document.getElementById('floorColor').addEventListener('change', (event) => {
            const color = new THREE.Color(event.target.value);
            floorObjects.forEach(obj => obj.material.color = color);
        });
        
        // Controls
        let wireframeMode = false;
        
        document.getElementById('resetCamera').addEventListener('click', () => {
            camera.position.set(5, 3, 8);
            camera.lookAt(0, 0, 0);
        });
        
        document.getElementById('toggleWireframe').addEventListener('click', () => {
            wireframeMode = !wireframeMode;
            scene.traverse((child) => {
                if (child.material) {
                    child.material.wireframe = wireframeMode;
                }
            });
        });
        
        // GLB Export functionality with proper binary format
        function createGLBExporter() {
            return {
                exportScene: function(scene) {
                    const gltf = {
                        asset: {
                            version: "2.0",
                            generator: "Workspace 3D Scene Generator"
                        },
                        scene: 0,
                        scenes: [{
                            name: "Workspace Scene",
                            nodes: []
                        }],
                        nodes: [],
                        meshes: [],
                        materials: [],
                        accessors: [],
                        bufferViews: [],
                        buffers: []
                    };
                    
                    const bufferData = [];
                    let bufferOffset = 0;
                    let nodeIndex = 0;
                    let meshIndex = 0;
                    let materialIndex = 0;
                    let accessorIndex = 0;
                    let bufferViewIndex = 0;
                    
                    // Process each mesh in the scene
                    scene.traverse((child) => {
                        if (child.geometry && child.material && child.type === 'Mesh') {
                            const geometry = child.geometry;
                            
                            // Extract vertex data
                            const position = geometry.attributes.position;
                            const normal = geometry.attributes.normal;
                            const index = geometry.index;
                            
                            if (position) {
                                // Position data
                                const positionArray = position.array;
                                const positionBuffer = new Float32Array(positionArray);
                                const positionBytes = new Uint8Array(positionBuffer.buffer);
                                bufferData.push(positionBytes);
                                
                                // Position buffer view
                                gltf.bufferViews.push({
                                    buffer: 0,
                                    byteOffset: bufferOffset,
                                    byteLength: positionBytes.length,
                                    target: 34962 // ARRAY_BUFFER
                                });
                                
                                // Position accessor
                                gltf.accessors.push({
                                    bufferView: bufferViewIndex,
                                    componentType: 5126, // FLOAT
                                    count: position.count,
                                    type: "VEC3",
                                    max: [
                                        Math.max(...Array.from(positionArray).filter((_, i) => i % 3 === 0)),
                                        Math.max(...Array.from(positionArray).filter((_, i) => i % 3 === 1)),
                                        Math.max(...Array.from(positionArray).filter((_, i) => i % 3 === 2))
                                    ],
                                    min: [
                                        Math.min(...Array.from(positionArray).filter((_, i) => i % 3 === 0)),
                                        Math.min(...Array.from(positionArray).filter((_, i) => i % 3 === 1)),
                                        Math.min(...Array.from(positionArray).filter((_, i) => i % 3 === 2))
                                    ]
                                });
                                
                                bufferOffset += positionBytes.length;
                                const positionAccessorIndex = accessorIndex++;
                                bufferViewIndex++;
                                
                                // Normal data (if available)
                                let normalAccessorIndex = null;
                                if (normal) {
                                    const normalArray = normal.array;
                                    const normalBuffer = new Float32Array(normalArray);
                                    const normalBytes = new Uint8Array(normalBuffer.buffer);
                                    bufferData.push(normalBytes);
                                    
                                    gltf.bufferViews.push({
                                        buffer: 0,
                                        byteOffset: bufferOffset,
                                        byteLength: normalBytes.length,
                                        target: 34962
                                    });
                                    
                                    gltf.accessors.push({
                                        bufferView: bufferViewIndex,
                                        componentType: 5126,
                                        count: normal.count,
                                        type: "VEC3"
                                    });
                                    
                                    bufferOffset += normalBytes.length;
                                    normalAccessorIndex = accessorIndex++;
                                    bufferViewIndex++;
                                }
                                
                                // Index data (if available)
                                let indexAccessorIndex = null;
                                if (index) {
                                    const indexArray = index.array;
                                    const indexBuffer = new Uint16Array(indexArray);
                                    const indexBytes = new Uint8Array(indexBuffer.buffer);
                                    bufferData.push(indexBytes);
                                    
                                    gltf.bufferViews.push({
                                        buffer: 0,
                                        byteOffset: bufferOffset,
                                        byteLength: indexBytes.length,
                                        target: 34963 // ELEMENT_ARRAY_BUFFER
                                    });
                                    
                                    gltf.accessors.push({
                                        bufferView: bufferViewIndex,
                                        componentType: 5123, // UNSIGNED_SHORT
                                        count: index.count,
                                        type: "SCALAR"
                                    });
                                    
                                    bufferOffset += indexBytes.length;
                                    indexAccessorIndex = accessorIndex++;
                                    bufferViewIndex++;
                                }
                                
                                // Create material
                                const material = {
                                    name: child.name + "_material",
                                    pbrMetallicRoughness: {
                                        baseColorFactor: [
                                            child.material.color.r,
                                            child.material.color.g,
                                            child.material.color.b,
                                            child.material.opacity || 1.0
                                        ],
                                        metallicFactor: 0.0,
                                        roughnessFactor: 1.0
                                    }
                                };
                                
                                if (child.material.transparent) {
                                    material.alphaMode = "BLEND";
                                }
                                
                                gltf.materials.push(material);
                                
                                // Create mesh
                                const meshAttributes = {
                                    POSITION: positionAccessorIndex
                                };
                                
                                if (normalAccessorIndex !== null) {
                                    meshAttributes.NORMAL = normalAccessorIndex;
                                }
                                
                                const primitive = {
                                    attributes: meshAttributes,
                                    material: materialIndex
                                };
                                
                                if (indexAccessorIndex !== null) {
                                    primitive.indices = indexAccessorIndex;
                                }
                                
                                gltf.meshes.push({
                                    name: child.name,
                                    primitives: [primitive]
                                });
                                
                                // Create node
                                gltf.nodes.push({
                                    name: child.name,
                                    mesh: meshIndex,
                                    translation: [child.position.x, child.position.y, child.position.z],
                                    rotation: [child.quaternion.x, child.quaternion.y, child.quaternion.z, child.quaternion.w],
                                    scale: [child.scale.x, child.scale.y, child.scale.z]
                                });
                                
                                gltf.scenes[0].nodes.push(nodeIndex);
                                
                                nodeIndex++;
                                meshIndex++;
                                materialIndex++;
                            }
                        }
                    });
                    
                    // Combine all buffer data
                    const totalBufferSize = bufferData.reduce((sum, buffer) => sum + buffer.length, 0);
                    const combinedBuffer = new Uint8Array(totalBufferSize);
                    let offset = 0;
                    
                    bufferData.forEach(buffer => {
                        combinedBuffer.set(buffer, offset);
                        offset += buffer.length;
                    });
                    
                    // Add buffer to GLTF
                    gltf.buffers.push({
                        byteLength: totalBufferSize
                    });
                    
                    return this.createGLB(gltf, combinedBuffer);
                },
                
                createGLB: function(gltf, binaryData) {
                    const gltfString = JSON.stringify(gltf);
                    const gltfBytes = new TextEncoder().encode(gltfString);
                    
                    // Pad JSON to 4-byte alignment
                    const gltfPadding = (4 - (gltfBytes.length % 4)) % 4;
                    const gltfPaddedLength = gltfBytes.length + gltfPadding;
                    
                    // Pad binary data to 4-byte alignment
                    const binaryPadding = (4 - (binaryData.length % 4)) % 4;
                    const binaryPaddedLength = binaryData.length + binaryPadding;
                    
                    // GLB header
                    const headerLength = 12;
                    const chunkHeaderLength = 8;
                    const totalLength = headerLength + chunkHeaderLength + gltfPaddedLength + chunkHeaderLength + binaryPaddedLength;
                    
                    const glb = new ArrayBuffer(totalLength);
                    const view = new DataView(glb);
                    let offset = 0;
                    
                    // GLB header
                    view.setUint32(offset, 0x46546C67, true); // 'glTF'
                    offset += 4;
                    view.setUint32(offset, 2, true); // version
                    offset += 4;
                    view.setUint32(offset, totalLength, true); // length
                    offset += 4;
                    
                    // JSON chunk header
                    view.setUint32(offset, gltfPaddedLength, true); // chunk length
                    offset += 4;
                    view.setUint32(offset, 0x4E4F534A, true); // 'JSON'
                    offset += 4;
                    
                    // JSON chunk data
                    const jsonChunk = new Uint8Array(glb, offset, gltfPaddedLength);
                    jsonChunk.set(gltfBytes);
                    // Pad with spaces
                    for (let i = gltfBytes.length; i < gltfPaddedLength; i++) {
                        jsonChunk[i] = 0x20;
                    }
                    offset += gltfPaddedLength;
                    
                    // Binary chunk header
                    view.setUint32(offset, binaryPaddedLength, true); // chunk length
                    offset += 4;
                    view.setUint32(offset, 0x004E4942, true); // 'BIN\0'
                    offset += 4;
                    
                    // Binary chunk data
                    const binaryChunk = new Uint8Array(glb, offset, binaryPaddedLength);
                    binaryChunk.set(binaryData);
                    // Pad with zeros
                    for (let i = binaryData.length; i < binaryPaddedLength; i++) {
                        binaryChunk[i] = 0;
                    }
                    
                    return glb;
                }
            };
        }
        
        document.getElementById('downloadGLB').addEventListener('click', async () => {
            const loadingText = document.getElementById('loadingText');
            const downloadBtn = document.getElementById('downloadGLB');
            
            loadingText.style.display = 'block';
            downloadBtn.disabled = true;
            
            try {
                const exporter = createGLBExporter();
                const glbBuffer = exporter.exportScene(scene);
                
                // Create blob and download
                const blob = new Blob([glbBuffer], { type: 'model/gltf-binary' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'workspace_scene.glb';
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
                
                alert('GLB file exported successfully!');
                
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed: ' + error.message);
            } finally {
                loadingText.style.display = 'none';
                downloadBtn.disabled = false;
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle rotation for flowers
            scene.children.forEach((child) => {
                if (child.material && child.material.color && child.material.color.getHex() === 0xFFD700) {
                    child.rotation.y += 0.005;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.setSize(rect.width, rect.height);
        });
    